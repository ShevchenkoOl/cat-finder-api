{"mappings":"AAyEA,IAAMA,KAAOC,SAASC,cAAc,SAC9BC,MAAQF,SAASC,cAAc,UACjCE,KAAO,EAELC,QAAU,CACdC,KAAM,KACNC,WAAY,QACZC,UAAW,GAGPC,kBAAoB,W,IAACC,EAAIC,UAAAC,OAAA,YAAAD,UAAA,GAAAA,UAAA,GAAG,EAC1BE,EAAW,uCACXC,EAAU,uBACVC,EAAO,gBACPC,EAAU,CACdC,OAAQ,MACRC,QAAS,CACPC,cAAe,UAAkBC,OAARN,KAI7B,OAAOO,MAAM,GAA6BD,OAA1BP,EAAS,mBAAyBO,OAARV,EAAK,KAAQU,OAALL,GAAQC,GAASM,MACjE,SAAAC,GAEE,IAAKA,EAAIC,GACP,MAAM,IAAIC,MAAMF,EAAIG,YAEtB,OAAOH,EAAII,M,KAKXC,YAAc,SAAAC,GAClB,IAAMC,EAASD,EACZE,KACC,SAAAC,G,IAAGC,EAAID,EAAJC,KAAMC,EAAIF,EAAJE,K,MACP,yBAEUd,OADAa,EAAK,2BACAb,OAALc,EAAK,uB,IAGlBC,KAAK,IACRnC,KAAKoC,mBAAmB,YAAaN,E,EAGjCO,OAAS,SAACC,EAASC,GACvBD,EAAQE,SAAQ,SAAAC,GACVA,EAAMC,gBAERjC,kBADAL,MAAQ,GACgBkB,MAAK,SAAAqB,GAC3Bf,YAAYe,EAAKC,MACdD,EAAKvC,OAASuC,EAAKE,OAClBN,EAASO,UAAU3C,M,IAGxB4C,OAAM,SAAAC,G,OAASC,QAAQC,IAAIF,E,QAKlCvC,oBACGa,MAAK,SAAAqB,GACJf,YAAYe,EAAKC,MACjBO,SAASC,QAAQjD,M,IAElB4C,OAAM,SAAAC,G,OAASC,QAAQC,IAAIF,E,IAE9B,IAAIG,SAAW,IAAIE,qBAAqBhB,OAAQhC","sources":["src/js/pagination.js"],"sourcesContent":["/*Алгоритм пагінаці:\n1. створюэмо функцыю, яка выдполвыдаэ за нпш HTTP-запит,lordOfTheRingsAPI = (page = 1) - вона приймає один параметр - сторінка, яку ми хочемо отримати по замовчуванню\n2. ми викликаєм функцію lordOfTheRingsAPI (), з елементами створення розмітки, які ми отримаємо від API;\n3. створюємо функцію creatMakeup (arr), яка приймає масив, який ми отримали від API, звідки ми берем 2 параметри name, race, і створюємо для низ розмітку\n4. створюємо послухач події на нашу кнопку завантаження load, по замовчуванню вона не видима, коли відрендериться розмітка вона зявляється\n*/\n// const list = document.querySelector('.list');\n// const load = document.querySelector('.load');\n// let page = 1;\n\n// const lordOfTheRingsAPI = (page = 1) => {\n//   // для пагінації ми передаем параметр page i по default встановоюємо значення 1, тобто починаєм з першої сторінки\n//   const BASE_URL = 'https://the-one-api.dev/v2/character';\n//   const API_KEY = 'XJlq9OFMcHAy8pAQK7xj';\n//   const sort = 'sort=name:asc'; //додаєм сортування\n\n//   const options = {\n//     // якщо у нас є авторизація тоді створюємо цей об'єкт, після чого передаєм його як другий параматр до fetch()\n//     method: 'GET',\n//     headers: {\n//       // по default, тип запиту завжди буде GET, якщо хочемо змінити тип запиту, то прописуэмо в options.method: 'POST' - перед headers\n//       Authorization: `Bearer ${API_KEY}`, // тут вказуємо ключ авторизаці та спосіб Bearer\n//     },\n//   };\n\n//   return fetch(`${BASE_URL}?limit=30&page=${page}&${sort}`, options)\n//   .then(res => {\n//     //console.log(res)\n//     if (!res.ok) {\n//       throw new Error(res.statusText); // якщо відповідь не 200, то повертаємо помилку, яку ми сами створили\n//     }\n//     return res.json();\n//   });\n// };\n\n// lordOfTheRingsAPI()\n//   .then(data => {\n//     creatMakeup(data.docs);\n//     load.hidden = false;\n//   })\n//   .catch(error => console.log(error));\n\n// const creatMakeup = arr => {\n//   const markUp = arr\n//     .map(\n//       ({ name, race }) =>\n//         `<li>\n//         <h2>${name}</h2>\n//         <h3>${race}</h3>\n//     </li>`\n//     )\n//     .join('');\n//   list.insertAdjacentHTML('beforeend', markUp);\n// };\n\n// load.addEventListener('click', () => {\n//   page += 1;\n//   lordOfTheRingsAPI(page) // - відправляємо запит на бекенд з параметром завантаженої сторінки\n//     .then(data => {\n//       //console.log(data)\n//       creatMakeup(data.docs);\n//       if (data.page === data.pages) { // робим перевірку, щоб поточна сторінка була рівна кількості сторінок ждя припинення пагинації\n//         // якщо ми законсолимо datа, то побачимо, що page=1 - це першп сторінка, pages=32 - це кількість всього сторінок\n//         load.hidden = true;\n//       }\n//     })\n//     .catch(error => console.log(error));\n// });\n\n//----------------------------Infinity scroll или бесконечной прокрутка или бесконечным скроллом\n\n//https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n\nconst list = document.querySelector('.list');\nconst guard = document.querySelector('.guard'); // цей дів створюється спеціально в кірці нашого списка, щоб ми бачили коли ми наближаємося до кінця viewport\nlet page = 1;\n\nconst options = {\n  root: null, //document.querySelector(\"#scrollArea\"), // відповідає за яким саме портом(скролом), нам треба слідкувати. Якщо ми використовуємо весь наш viewport, то root: null;\n  rootMargin: '300px', // за скільки пікселів до вхолодження в viewport треба спрацювати\n  threshold: 1.0, // незовсім потрібний параметр, якщо ми становили rootMargin: \"300px\" або інше значення крім 0, то цей параметр просто вставляємо з документації\n};\n\nconst lordOfTheRingsAPI = (page = 1) => {\n  const BASE_URL = 'https://the-one-api.dev/v2/character';\n  const API_KEY = 'XJlq9OFMcHAy8pAQK7xj';\n  const sort = 'sort=name:asc';\n  const options = {\n    method: 'GET',\n    headers: {\n      Authorization: `Bearer ${API_KEY}`,\n    },\n  };\n\n  return fetch(`${BASE_URL}?limit=30&page=${page}&${sort}`, options).then(\n    res => {\n      //console.log(res)\n      if (!res.ok) {\n        throw new Error(res.statusText);\n      }\n      return res.json();\n    }\n  );\n};\n\nconst creatMakeup = arr => {\n  const markUp = arr\n    .map(\n      ({ name, race }) =>\n        `<li>\n            <h2>${name}</h2>\n            <h3>${race}</h3>\n        </li>`\n    )\n    .join('');\n  list.insertAdjacentHTML('beforeend', markUp);\n};\n\nconst onLoad = (entries, observer) => { // цю функцію з параметрами ми берем із\n  entries.forEach(entry => {\n    if (entry.isIntersecting) {\n      page += 1;\n      lordOfTheRingsAPI(page).then(data => {\n        creatMakeup(data.docs);\n        if(data.page === data.pages) {\n            observer.unobserve(guard); // якщо ми дійшли до останнбої сторінки, то відписуємо обсервера не спостерігати \n        }\n      })\n      .catch(error => console.log(error));\n    }\n  });\n};\n\nlordOfTheRingsAPI()\n  .then(data => {\n    creatMakeup(data.docs);\n    observer.observe(guard); // обсервер спостерігай коли ми наближимося до кінця списка\n  })\n  .catch(error => console.log(error));\n\nlet observer = new IntersectionObserver(onLoad, options);\n"],"names":["list","document","querySelector","guard","page","options","root","rootMargin","threshold","lordOfTheRingsAPI","page1","arguments","length","BASE_URL","API_KEY","sort","options1","method","headers","Authorization","concat","fetch","then","res","ok","Error","statusText","json","creatMakeup","arr","markUp","map","param","name","race","join","insertAdjacentHTML","onLoad","entries","observer1","forEach","entry","isIntersecting","data","docs","pages","unobserve","catch","error","console","log","observer","observe","IntersectionObserver"],"version":3,"file":"pagination.d6d3e94e.js.map"}